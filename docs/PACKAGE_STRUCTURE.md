# 📦 패키지 별 역할

## 패키지 구조에 대해 고려한 점

1. 개발 형식이 고정될 수 밖에없는 과제이지만, 유지 보수 관점도 고려해야 한다 생각합니다.

- 개발에서 가장 힘들게 하는 것이 유지 보수라 생각하기에, 확장성을 고려했습니다.

2. 하지만, YAGNI (You Aren't Gonna Need It) 원칙, 과한 기능에 대해서도 고민해보았습니다.

- 인터페이스 적용은 캡슐화의 장점을 가집니다.
  하지만,무조건적으로 계층 간 인터페이스를 적용하여, 인터페이스과 구현체가 1:1로 구성되면 오히려 복잡도만 높힌다는 피드백이 있었습니다.
  때문에, 설명할 수 있는 근거가 있는 경우에만 적용했습니다.
  (ex. Repository와 View는 외부 시스템과의 결합도를 낮추기 위해 인터페이스를 도입했습니다.)

3. 전통적인 MVC 패턴에서 Model에 대해 도메인 주도적으로 접근하고자 했습니다.

> 관련 함수를 묶어 클래스를 만들고, 객체들이 협력하여 하나의 큰 기능을 수행하도록 한다.

- 위 학습 목표를 수행하기 위해, 세분화된 도메인마다 관심있는 작업을 스스로 처리하는 객체로 구성합니다.
- 도메인 패키지 내 각각은 해당 클래스에 관심있는 내용만 다루도록 직관적으로 책임을 분리합니다.

4. 또한, 명확한 기준을 세우기 위해 아래와 같이 패키지 별 역할을 명세하여 지켰습니다.

- 이전 과제를 돌이켜보았을 때, Model을 명확한 기준없이 Entity와 VO로 나눈 것을 반성하기 위함입니다.

```
 store/
    ├── common/
    │   ├── config/
    │   ├── constant/
    │   └── util/
    ├── controller/
    ├── domain/
    │   ├── stock/
    │   │   ├── repository/
    │   │   ├── Stock.java
    │   │   └── StockFactory.java
    │   ├── promotion/
    │   └── receipt/
    ├── dto/
    │    └── converter/
    ├── repository/
    ├── view/
    │   ├── impl/
    │   └── interfaces/
    └── Application.java
```

각 패키지 별 역할과 특징은 다음과 같습니다.

## 🗂️ Common/

- 프로젝트 전반에서 사용되는 클래스의 집합입니다.
- config/DependingConfig는 의존성 주입을 관리합니다.
-

## 📂 Controller/

- 모델과 View 사이 중재자 역할을 수행한다.
- 호출과 실행의 흐름 제어가 주된 목적으로, 비즈니스 로직을 포함하지 않습니다.

## 📂 Domain/

- 비즈니스 로직의 핵심이 되는 도메인 모델들이 위치합니다.
- 각 핵심 모델들은 스스로 행위를 할 수 있는 객체로서 정의합니다.
- 모델의 정적 메소드 사용을 최소화합니다. 정적 생성기 호출이 필요한 경우에는 Factory를 사용합니다.

## 📂 DTO/

- 계층 간 데이터 전송에 사용되는 DTO(Data Transfer Object) 클래스들이 위치합니다.
- Repository로의 요청/응답 데이터의 전달 객체들이 포함합니다.

## 📂 Repository/

- resources 폴더의 md 파일에 접근해 데이터를 조회, 수정합니다.
- 해당 클래스들은 추후 데이터 저장소 변경 등을 고려하여, Interface를 상속받습니다.

## 📂 View/

- View는 사용자 인터페이스로 IO 제어 및 관리를 담당합니다.
- 이때, InputView는 Console이라는 별도의 라이브러리에 의존하며, <br>
  OutputView는 개발 환경에 따라 변화할 여지가 있습니다. ( GUI라던가,,)<br>
  따라서, 외부 시스템이 변경되더라도 핵심 비즈니스 로직에는 영향을 주지 않도록 Interface로 추상화했습니다.
